# Задача А: Выражения-генераторы
Вам предлагается набор из задачек, для каждой из которых решение — одно выражение-генератор.
1. Трансформация выражения (переведите выражение слева в выражение справа):

    'python' -> ['pppp', 'yyyy', 'tttt', 'hhhh', 'oooo', 'nnnn']

2. Трансформация выражения:

    'python' -> ['p', 'yy', 'ttt', 'hhhh', 'ooooo', 'nnnnnn']

3. Трансформация выражения:

    range(16) -> [0, 3, 5, 6, 9, 10, 12, 15]

4. Трансформация выражения:

    [[1, 2, 3], [4, 5, 6, 7], [8, 9], [0]] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

5. Пифагоровы тройки.
Выведите все уникальные пифагоровы тройки, где каждое из чисел не превосходит n. На вход подается число n (n ≤ 30).

    15 -> [(3, 4, 5), (5, 12, 13), (6, 8, 10), (9, 12, 15)]

6. Трансформация выражения:

    ([0, 1, 2], [0, 1, 2, 3, 4]) -> [[0, 1, 2, 3, 4], [1, 2, 3, 4, 5], [2, 3, 4, 5, 6]]

7. Транспонирование матрицы.

    [[1, 2], [3, 4], [5, 6]] -> [[1, 3, 5], [2, 4, 6]]
    [[1, 3, 5], [2, 4, 6]] -> [[1, 2], [3, 4], [5, 6]]

8. Трансформация выражения:

    ["0", "1 2 3", "4 5 6 7", "8 9"] -> [[0], [1, 2, 3], [4, 5, 6, 7], [8, 9]]

9. Трансформация выражения:

    range(0, 7) -> {'a': 0, 'b': 1, 'c': 4, 'd': 9, 'e': 16, 'f': 25, 'g': 36}

10. Трансформация выражения:

    ['Alice', 'vova', 'ANTON', 'Bob', 'kAMILA', 'CJ', 'ALICE', 'Nastya'] -> {'Alice', 'Anton', 'Kamila', 'Nastya', 'Vova'}

## Формат результата
Оформите свое решение в виде функций solution{n}(arg), где {n} — номер задания. На вход этим функциям в качестве аргумента будут подаваться выражения из левой части. Поместите ваши функции в словарь.

```py
solutions = {
    'solution1': solution1,
    'solution2': solution2,
    'solution3': solution3,
    'solution4': solution4,
    'solution5': solution5,
    'solution6': solution6,
    'solution7': solution7,
    'solution8': solution8,
    'solution9': solution9,
    'solution10': solution10,
}
```
## Решение
    A.py

# Задача B: map, filter и reduce

Вам предлагается набор из задачек, для каждой из которых решение — одно выражение с использованием функций map, filter и reduce.

1. Трансформация выражения (переведите выражение слева в выражение справа):

    ['12', '25.6', '84,02', '  69-91'] -> [21, 652, 2048, 1996]

2. Трансформация выражения:

    zip(range(2, 5), range(3, 9, 2)) -> [6, 15, 28]

3. Трансформация выражения:

    range(20) -> [0, 2, 5, 6, 8, 11, 12, 14, 17, 18]

4. Трансформация выражения:

    ['', 25, None, 'python', 0.0, [], ('msu', '1755-01-25')] -> [25, 'python', ('msu', '1755-01-25')]

5. Добавьте к каждому элементу списка rooms поле square, показывающее площадь комнаты. Элементы списка rooms ДОЛЖНЫ обновиться!

```py
rooms = [
    {"name": "комната1", "width": 2, "length": 4},
    {"name": "комната2", "width": 2.5, "length": 5.6},
    {"name": "кухня", "width": 3.5, "length": 4},
    {"name": "туалет", "width": 1.5, "length": 1.5},
]
```

6. Добавьте к каждому элементу списка rooms поле square, показывающее площадь комнаты. Элементы исходного списка rooms НЕ ДОЛЖНЫ обновиться! Порядок элементов в результирующем списке должен совпадать с порядком в исходном списке.
Подсказка

Замечание: запрещается использовать модуль copy.

7. Найдите пересечение всех множеств. Используйте функцию reduce.

    [{1, 2, 3, 4, 5}, {2, 3, 4, 5, 6}, {3, 4, 5, 6, 7}] -> {3, 4, 5}

8. Посчитайте, сколько раз встречается каждый элемент в списке.

    [1, 2, 1, 1, 3, 2, 3, 2, 4, 2, 4] -> {1: 3, 2: 4, 3: 2, 4: 2}

Замечание: запрещается использовать класс Counter из модуля collections.

9. Выведите имена студентов, чей GPA > 4.5.

```py
students = [
    {'name': 'Alina', 'gpa': 4.57},
    {'name': 'Sergey', 'gpa': 5.0},
    {'name': 'Nastya', 'gpa': 4.21},
    {'name': 'Valya', 'gpa': 4.72},
    {'name': 'Anton', 'gpa': 4.32},
]
```

students -> ['Alina', 'Sergey', 'Valya']

10. Счастливые билетики по-питерски.

Билетик называется счастливым, если сумма цифр на четных местах равна сумме цифр на нечетных. Из исходного списка выведите только счастливые билетики.

Пример:

['165033', '477329', '631811', '478117', '475145', '238018', '917764', '394286'] -> ['165033', '475145', '238018']


Замечание: разрешается использовать функцию sum.

## Формат результата

Оформите свое решение в виде функций solution{n}(arg), где {n} — номер задания. На вход этим функциям в качестве аргумента будут подаваться выражения из левой части (в заданиях на трансформацию) или один из списков: rooms, people, students. Поместите ваши функции в словарь.

```py
solutions = {
    'solution1': solution1,
    'solution2': solution2,
    'solution3': solution3,
    'solution4': solution4,
    'solution5': solution5,
    'solution6': solution6,
    'solution7': solution7,
    'solution8': solution8,
    'solution9': solution9,
    'solution10': solution10,
}
```

## Решение
    B.py


# Задача C. Кто не успел, тот опоздал

В системах реального времени не редко бывают ограничения на время ответа -- пользователь вашего сервиса не будет ждать ответа бесконечно долго. Например, если пользователь что-то ищет в вашем поиске имеет смысл показать ему хоть что-то более менее соответствующее запросу, нежели не показать ничего. Чтобы определить, что мы не успеваем отдать ответ пользователю за заранее определенное время используется механизм таймаутов.

В этом задании предлагается написать декоратор @timeout(seconds=0.1), который будет прерывать выполнение функции и бросать исключение TimeoutException, если функция не укладывается в заданное число секунд.

```py
class TimeoutException(RuntimeError):
    def __init__(self, message=None):
        super().__init__(message)
```

Решение предлагается сделать с использование сигналов. В качестве используемого сигнала стоит выбрать signal.SIGALRM. Для установки таймера используйте:

```py
signal.setitimer(signal.ITIMER_REAL, seconds)
```

В случае, если аргумент seconds равен None или является не положительным числом, считается, что таймаут для функции не устанавливается (функция не оборачивается в декоратор).

## Решение
    C.py

# Задание D. Счетчики

Напишите декоратор @counter, который позволял бы посчитать глубину рекурсии функции и количество рекурсивных вызовов функции.

Декоратор должен создать два атрибута для функции:

    ncalls — число вызовов функции;
    rdepth — глубина рекурсии.

Счётчики ncalls и rdepth должны обнуляться при каждом новом входе в рекурсию.

## Решение
    D.py

# Задание E. Змейка

В модуле itertools есть функция chain, которая позволяет последовательно объединять несколько итерируемых объектов.

Напишите генератор-функцию chain_loop(args), который бы:

* циклически обходил бы объекты в args;
* из каждого объекта элементы извлекались бы в порядке их очереди;
* если в некотором объекте элементы закончились, то этот объект нужно игнорировать (см. замечание) при циклическом обходе;
* генератор завершает свою работу тогда, когда все элементы из всех объектов в args были извлечены.

Постарайтесь придумать максимально общее решение без предположения о том, что какие-то значения точно будут отсутствовать в элементах args.

## Решение
    E.py

# Задача F. Скобочные последовательности

Рассмотрим последовательность из n открывающихся и n закрывающихся круглых скобок. Последовательность называется правильной, если в любом ее префиксе число открывающих скобок не меньше числа закрывающих. Префиксом последовательности называется последовательность из первых k (целое) элементов последовательности.

Все правильные последовательности для n = 3:

()()(), (())(), ()(()), (()()), ((()))

Напишите функцию-генератор brackets(n) всех правильных скобочных последовательностей длины 2n.

# Формат входных данных

На вход вашей программе подается единственное число n (0 ≤ n ≤ 10).

# Формат результата
Выведите все правильные скобочные последовательности длины 2n в лексикографическом порядке.

## Решение
    F.py

# Задача G. Неправильный словарь

В модуле collections есть класс defaultdict, который позволяет создавать словарь со значением по-умолчанию.

Пусть:

    smartdict – (обычный) словарь (dict), который хранит в себе некоторый defaultdict;
    key – некоторый ключ в словаре smartdict;
    val – значение в словаре smartdict по ключу key: val = smartdict[key].

Значение по-умолчанию для val определим, как smartdict_nan(key).

Имеется следующая реализация:

```py
from collections import defaultdict

def smartdict_nan(key):
    return 10 * key

N = 10

smartdict = {}
for key in range(N):
    val = defaultdict(lambda: smartdict_nan(key))
    smartdict[key] = val
```

При такой реализации словарь smartdict работает не так, как было задумано.

```py
>>> smartdict[5]['key_unknown']
90 # right answer is 50

>>> smartdict[7]['key_unknown']
90 # right answer is 70

>>> smartdict[2]['key_unknown']
90 # right answer is 20
```

Объясните, почему код работает неверно (в комментарии к решению), и исправьте ошибку. Разворачивать цикл в последовательные вызовы запрещено. Чем подробнее будет ваше объяснение, тем выше вероятность, что оно будет правильно понято и задание будет засчитано.

## Решение
    G.py


# Задание H. Префиксоное дерево поиска

## Решение
    H.py

# Задание I. Хрупкий словарь

В банках всего мира используются SQL-базы данных. Основным преимуществом этих баз данных является высокая скорость доступа к данным, а также выполнение принципов ACID (атомарность, согласованность, изолированность, долговечность). Транзакции обязаны удовлетворять этим принципам, иначе любая ошибка может привести к огромным потерям со стороны банка.

В этом задании предлагается реализовать прототип простейшего "безопасного" хранилища. Наше хранилище будет называться «хрупким словарем». Класс FragileDict должен реализовывать следующий интерфейс:

1. Инициализатор опционально может принимать на вход словарь, содержимое которого будет храниться в «хрупком словаре». В конструкторе заполняются два атрибута: _data — хранилище с данными, _lock — булев флаг, показывающий разрешено ли редактировать хранилище (True в положении вне контекста). Других полей быть НЕ должно.

2. Из любого экземпляра класса FragileDict можно читать данные аналогично тому, как это делается для словарей, например, d['key']. Если ключ (key) отсутствует, то бросается исключение KeyError(key), как если бы это был просто словарь.

3. Класс FragileDict должен поддерживать механизм менеджера контекста. Экземпляр класса может создаваться при входе в контекст.

4. В экземпляры класса можно записывать данные аналогично тому, как это делается для словарей, например, d['key'] = value. Однако разрешается это делать только внутри контекста. Если этот контракт нарушается, то бросается исключение RuntimeError("Protected state"). При входе в контекст разрешается создавать любые атрибуты класса, но на выходе из контекста никаких сторонних атрибутов быть не должно.

5. Если внутри контекста возникло исключение, то данные не записываются. На выходе из контекста «словарь» должен иметь точно такое же состояние, как и на входе. Само исключение подавляется, и пишется сообщение об ошибке "Exception has been suppressed.".

6. Класс должен поддерживать проверку наличия ключа в формате key in d, где key — некоторый ключ, а d — экземпляр класса «хрупкого словаря».

## Решение
    I.py
